# 인증체계

## 1. Cookie

쿠키란 사용자가 웹 사이트에 접속할 때, 그 사이트가 사용하게 되는 작은 기록 파일이다.

(Key, Value) 형식의 문자열 형태로 저장되어 사용된다.

### 작동방식

1. 클라이언트가 아이디, 비밀번호를 통해 서버에 로그인 요청을 한다.
2. 서버는 이를 인증한 후, key-value의 형태로 쿠키에 저장하여 헤더에 담아 클라이언트에게 전달한다.
3. 클라이언트는 인증이 필요할 때마다, 이 전달받은 쿠키를 헤더에 담아 서버에 전달한다.

### 단점

- 쿠키는 노출이 되었을 때, 아이디와 비밀번호같은 민감한 정보까지 다 노출이 되어 보안이 좋지않다.
- 조작당해서 들어올 가능성이 있다.
- 웹 브라우저마다 쿠키에 대한 지원 형태가 다르기에 다른 브라우저간의 공유가 불가능하다.
- 쿠키는 사이즈가 제한(4KB)되어 있어 원하는 만큼의 충분한 데이터를 담을 수 없다.
- 서버는 매번 아이디와 비밀번호를 받아서 인증을 해야하는 불편함이 있으며 조작된 데이터가 넘어오는 경우를 방지할 수 없다.

---

## 2. Cookie + Session

쿠키만 사용하여 인증받는 체계의 경우 **매번 인증이 필요할 때 마다, 민감한 정보가 작성된 상태의 쿠키를 전달**하게 된다.

이는 쿠키를 탈취당했을 때, **민감한 정보를 그대로 노출할 수 있기에,** 이를 방지하기 위해서 사용되는 인증방식이다.

아이디와 비밀번호를 주고받지 않고, 인증 정보 자체를 특정 세션 저장소에 저장하고, 이 값을 쿠키에 담아 클라이언트가 쿠키를 요청할 때마다 세션 저장소에 있는 정보랑 동일한지로 로그인을 확인한다.

### 작동방식

1. 클라이언트가 아이디, 비밀번호를 통해 서버에 로그인 요청을 한다.
2. 서버는 이를 인증한 후, 이 사용자를 식별할 특정 유니크한 세션ID를 만들어서 자물쇠처럼 서버의 세션 저장소에 저장을 한다.
    1. 세션 ID를 특정한 형태(Cookie or Json)로 클라이언트에게 다시 반환한다.
3. 클라이언트는 사용자 인증이 필요한 정보를 요청할 때마다 이 세션ID를 쿠키에 담아 서버에 함께 전달한다.
4. 인증이 필요한 api일 때, 서버는 세션ID가 세션저장소에 있는지 확인한다.
5. 만약 있다면, 인증 완료 후, API를 처리, 없다면 401에러를 반환한다.

만약 보안문제가 발생한다면  그냥 세션 저장소를 전부 지우면 해결가능하다.

(이는 반대로 세션저장소에 문제가 발생한다면, 정상적인 사용자가 인증을 못하게 되는 문제가 발생할 수 있다.)

### 단점

- 세션 저장소에 문제가 발생하면, 인증체계가 무너져 이전의 다른 인증된 유저 또한 인증을 할 수 없다.
- stateful 하기 때문에, http의 장점을 발휘하지 못하고, scale out에 걸림돌이 생긴다.
    - http의 장점은 stateless하다는 것이다. 서버의 세션 저장소에 세션ID를 저장함으로써, 상태를 저장하는 일이 발생하기 때문에, stateful한 상황이 발생하는 것이다.
    - scale out이란 서버를 늘리고 싶을 때를 말한다. 서버를 늘리고 싶은데, 이전의 서버의 세션 저장소에 정보가 저장되어 있기 때문에, 따로 이 정보를 저장해야하는 번거로움이 발생한다.
- 세션 저장소가 필수적으로 존재하기에, 이를 사용하기 위한 비용이 발생한다.
- 세션ID가 탈취됐을 경우, 대처는 가능하지만, 클라이언트인 척 위장하는 보안의 약점이 있을 수 있다.
- 사용자가 많아질 수록 메모리를 많이 차지한다.
- 사용자가 인증을 요구할 때마다, 세션 저장소를 조회해야한다.

---

## 3. JWT(Json Web Token)

세션을 사용하여 인증하는 방식의 단점은 **조회하는 작업이 발생**한다는 것이다.

이를 해결하기 위해 등장한 것이 **JWT** 이다.

인증방식은 Cookie와 크게 다르지 않다. 하지만 쿠키와 다르게 JWT의 경우 **서명된 토큰이라는 차이점**이 존재한다.

공개/개인 키를 쌍으로 사용하여 토큰에 서명을 한다.

이렇게 발급된 토큰은 개인 키를 보유한 서버가 이 서명된 토큰이 정상적인 토큰인지 인증할 수 있다.

### JWT의 구조

JWT는 각각의 구성요소가 점(.)으로 구분되어 있으며, 구성요소는 다음과 같다.

- Header
- Payload
- Signature

ex) Header.Payload.Signature → HHHHH.PPPPP.SSSSS

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

### 1. Header

헤더에는 보통 토큰의 타입이나, 서명 생성에 어떤 알고리즘이 사용되었는지를 저장

```jsx
{
	"typ": "JWT",
	"alg": "HS512"
}
```

이와 같이 사용하면, Type은 “JWT”, 알고리즘은 “HS512”라는 알고리즘을 통해 암호화 되어있다는 의미이다.

### 2. Payload

payload에는 보통 Claim이라 불리는 사용자에 대한, 토큰에 대한 property를 key-value의 형태로 저장한다.

이 Claim에는 JWT의 표준 스펙이 있는데, 표준 스펙 상 key의 이름은 3글자로 되어있다. 이는 정의되어 있는 Claim에 대한 스펙이 있다는 것이지, 꼭 이들을 무조건 포함해서 생성해야한다는 의미는 아니다.

JWT 표준 스펙

1. iss (issuer): 토큰 발급자
2. sub (Subject): 토큰 제목 - 토큰에서 사용자에 대한 식별 값이 된다.
3. aud (Audience): 토큰 대상자
4. exp (Expiration Time): 토큰 만료 시간
5. nbf (Not Before): 토큰 활성 날짜 (이 날짜 이전의 토큰은 활성화되지 않음)
6. iat (Issued At): 토큰 발급 시간
7. jti (JWT Id): JWT 토큰 식별자 (issuer가 여러 명일 때, 이를 구분하기 위한 값)

이 외에 자율적으로 추가하고싶은 property가 있다면 추가해도 개발자의 자유이며, 이름을 꼭 3글자로 규정할 필요도 없다.

```jsx
{
	"sub": "1",
	"iss": "hand",
	"exp": "1636989718",
	"iat": "1636989718",
	"token-type": "access token"
}
```

이와 같이 사용하며, 위의 Payload내용을 분석하자면, 토큰 제목은 “1”이고, 발급자는 “hand”이다. 만료시간과 발행시간이 같아서 어차피 사용하지 못할 토큰이며, 토큰타입은 “access token”을 넣어 access token 기능을 위해 발급된 토큰임을 알 수 있다.

중요한 점은 바로 **payload에 민감한 정보를 절대 담지 않는 것이다.**

[JWT.IO](https://jwt.io/)

위의 사이트에서 확인해보면, header와 payload는 json이 특별한 암호화가 걸려 인코딩되어있는 것이 아니기에, 누구나 jwt를 가지고 디코딩을 한다면, header나 payload에 담긴 값을 알 수 있기 때문이다.

### 3. Signature

가장 중요한 Signature의 경우 암호화가 되어 있다.

```jsx
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  your-256-bit-secret
)
```

이와 같이 header를 디코딩한 값, payload를 디코딩한 값을 합치고, 이를 your-256-bit-sercret이라는 서버가 가지고 있는 개인키를 통해서 암호화가 되어있다.

따라서, 서버가 가지고 있는 개인키로만 암호화를 풀 수 있으므로, 다른 클라이언트가 접근해 Signature를 복호화할 수 없다.

### 작동방식

1. JWT토큰을 클라이언트가 서버로 요청과 동시에 전달한다.
2. 서버가 가지고 있는 개인키를 통해 Signature를 복호화한 다음, base64Encode(header)가 JWT가 가지고 있는 Header의 정보과 일치하는 지, payload가 일치하는 지를 확인하여 일치한다면 인증을 허용한다.

만약 클라이언트가 payload에 담긴 식별자가 변조된 JWT로 요청을 하더라도 서버가 발급한 Signature의 payload와 다르기 때문에 인증이 불가능하다.

### 장점

- 세션저장소와 같은 별도의 인증 저장소가 “필수적"으로 필요하지 않다.
- 클라이언트의 상태를 서버에 저장해 두지 않아도 된다.
- Signature를 공통 키, 개인키 암호화를 통해 막아두어 데이터에 대한 보완성이 증가한다.
- 다른 서비스에 이용할 수 있는 공통적인 스펙으로써 사용할 수 있다.

### 단점

- 토큰 탈취 시, 토큰을 무효화할 방법이 없다.
    - 이를 위해 access token, refresh token 두 가지 토큰을 사용한다.
    - access token: 인증을 위해 사용하는 토큰 (보통 수명을 짧게 잡아서 탈취가 되더라도 금방 수명이 다할 수 있도록 구성된다.)
    - refresh token: access token의 수명이 다했을 때, refresh token을 통해 재발급 받을 수 있다. (수명을 길게 설정한다.)