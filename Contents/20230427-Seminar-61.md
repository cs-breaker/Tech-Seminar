db의 동시성과 isolation 관점에서 여러 이상 현상이 있는데 미묘하게 달라서 헷갈리는 경우가 많다. 따라서 정리해 봤다.
## dirty read
---

커밋되지 않은 값을 읽는 행위이다.

1. 트랜젝션 1이 x를 읽음
2. 트랜젝션 2가 y에 70을 쓴다.
3. 트랜젝션 1이 x에 x+y를 쓴다.
4. 트랜젝션 2가 rollback함.

이 경우에 트랜젝션 2가 커밋하지 않은 내용을 바탕으로
트랜젝션 1이 어떤 연산을 수행했는데 트랜젝션 2가 rollback을 할 경우 문제가 된다.

꼭 rollback을 하는 경우에만 문제가 되는 것은 아니다.

계좌이체의 경우를 예로 들면 어떤 트랜젝션이 계좌이체를 하고 있을 때 다른 트랜젝션이 중간에 잔액을 읽게 되면 두 계좌의 총합이 달라지게 되고 데이터 정합성이 깨진다.

---
## NonRepeatable Read
---
한 트랜젝션 내에서 어떤 데이터의 값을 변경하지 않았는데
다시 읽었을 때 값이 다른 상황

1. 트랜젝션 1이 x에서 10을 읽어옴.
2. 트랜젝션 2가 x에 50을 쓴다.
3. 트랜젝션 2 commit
4. 트랜젝션 1이 x에서 50을 읽어옴.

이 경우 1번과 4번에서 같은 트랜젝션에서 읽기 쿼리를 2번 연속으로 날렸는데 값이 달라져 있다.

---
## Phantom Read
---
한 트랜잭션 내에서 어떤 데이터를 추가하거나 삭제하지 않았는데 결과값이 달라지는 현상.

1. 트랜젝션 1이 조건 v를 만족하는 행들을 읽음
2. 트랜젝션 2가 조건 v를 만족하는 행을 추가, 삭제
3. 트랜젝션 2 commit
4. 트랜젝션 1이 조건 v를 만족하는 행들을 읽음

이 때 1번과 4번의 결과가 달라지게 된다.

---

위의 3가지 이상 현상은 격리 수준을 나누는 기준이 된다.
1992년 발표된 sql 표준에 따르면

허용 기준

Read uncommitted : dirty read, Non-Repeatable Read, Phantom read

Read committed : Non-Repeatable Read, Phantom read

Repeatable read : Phantom read

Serializable : X

하지만 dbms마다 구현이 다르기 때문에 사용하는 dmbs의 공식 문서를 따져봐야 한다.

oracle의 경우 repeatable read를 보장하려면 serializable이 필요하고

mysql의 innodb의 경우 repeatable read에서도 phantom read가 발생하지 않는다.

---
## 추가적인 이상 현상
---

위에서 정의한 3개 만으로 이상 현상을 정의하기에는 부족하다. 추가적으로 많이 사용되는 이상 현상에 대한 정의를 소개한다.

---
## dirty write
---

commit 안된 데이터를 write하는 행위

기존의 x가 0이라고 하면 

1. 트랜젝션 1이 x에 10을 쓴다.
2. 트랜젝션 2가 x에 100을 쓴다.
3. 트랜젝션 1이 rollback(x가 0으로 변경)

여기서

4. 트랜젝션 2가 commit

이렇게 되면 트랜젝션 2는 commit을 했음에도 자신이 작성한 내용이 지워지게 된다.

만약에

4. 트랜젝션 2가 rollback(x가 10으로 변경)

이렇게 되면 1, 2가 전부 rollback했음에도 기존의 값인 0이 아니라 다른 값이 들어있게 된다.

이전에 올렸던 

https://github.com/cs-breaker/Tech-Seminar/blob/main/Contents/20230306-Seminar-55.md 

내용의 log가 어떻게 작성되고 rollback되는지 본다면 이해가 될 것이다.

rollback시에 정상적인 recovery는 매우 중요하기 때문에 대부분의 dbms에서 모든 isolation level에서 dirty write는 허용하지 않는다고 알고 있다.

---
## Lost Update

---

어떤 commit의 

1. 트랜젝션 1이 x에서 50을 읽음
2. 트랜젝션 2가 x에서 50을 읽음
3. 트랜젝션 2가 x에 200을 쓴다.
4. 트랜젝션 2 commit
5. 트랜젝션 1이 x에 100을 쓴다.
6. 트랜젝션 1 commit


이 경우 트랜젝션 2의 변경 사항은 무시되게 된다.

lost update는 굉장히 심각하면서도 쉽게 발생할 수 있다. 이런 경우는 select for update와 같이 read를 한 행에 exclusive lock을 걸어야 해결할 수 있다.

---

## read skew
---

데이터 정합성이 맞지 않는 읽기를 read skew라고 한다. 

초기값 x = 50 , y = 50에서 
트랜젝션 2가 x에서 y에 40을 계좌이체하는 경우

1. 트랜젝션 1이 x에서 50을 읽음
2. 트랜젝션 2가 x에서 50을 읽음
3. 트랜젝션 2가 x에서 40을 뺌(10)
4. 트랜젝션 2가 y에서 50을 읽음
5. 트랜젝션 2가 y에 40을 더함(90)
6. 트랜젝션 2 commit
7. 트랜젝션 1이 y에서 90을 읽음

이 경우 트랜젝션 1에서 두 계좌의 합이 140이 된다. 즉 데이터 정합성이 깨진 상황이다.

Non-Repeatable read와의 차이점은 같은 데이터를 읽느냐, 연관된 데이터를 읽느냐에 있다.

---

## write skew
---
데이터 정합성이 맞지 않는 쓰기를 write skew라고 한다.

초기값 x = 50, y = 50에서

트랜젝션 1은 x에서 80을 인출하고

트랜젝션 2는 y에서 90을 인출할 때

x와 y의 합이 0이상이여야 한다는 제약이 걸려있다고 하자.

1. 트랜젝션 1이 x, y에서 50씩 읽어옴
2. 트랜젝션 2가 x, y에서 50씩 읽어옴
3. 트랜젝션 1이 x에 -30을 씀(80 인출)
4. 트랜젝션 2가 y에 -40을 씀(90 인출)
5. 트랜젝션 1, 2 commit

이 경우 serializable하게 동작했다면 한 트랜젝션은 거부당했을 것이다. 하지만 concurrency를 허용했기 때문에 데이터 정합성이 맞지 않게 되었다.
