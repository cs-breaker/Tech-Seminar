# HTTP 캐시

웹 캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치

웹 요청이 캐시에 도착했을 때, 캐시된 로컬 사본이 존재한다면, 그 문서는 원 서버가 아니라 캐시로부터 제공된다.

### 캐시를 사용하는 이유

1. 캐시는 불필요한 데이터 전송을 줄여서, 네트워크 요금으로 인한 비용을 줄인다.

2. 캐시는 네트워크 병목을 줄여준다. 대역폭을 늘리지 않고도 페이지를 빨리 불러올 수 있게 된다.

3. 캐시는 원 서버에 대한 요청을 줄여준다. 서버는 부하를 줄일 수 있으며 더 빨리 응답할 수 있게 된다.

4. 페이지를 먼 곳에서 불러올수록 시간이 많이 걸리는데, 캐시는 거리로 인한 지연을 줄여준다.

### cache hit, miss, revalidation

cache hit : 캐시에 요청이 도착했을 때, 대응하는 사본이 있다면 요청 처리

cache miss : 대응하는 사본이 없다면 원 서버로 전달

revalidation : 원 서버의 문서가 변경될 수 있기 때문에, 캐시는 반드시 사본이 최신인지 원 서버를 통해 점검해야 한다. 그러나 캐시는 수백만 개씩 갖고 있는 경우가 흔한 것에 비해 네트워크 대역폭이 부족하기 때문에, 대부분의 캐시는 사본이 검사를 할 필요가 있을 정도로 충분히 오래된 경우에만 재검사를 한다

### cache의 종류

private cache : 웹 브라우저에 저장되는 캐시이며, 다른 사람이 접근할 수 없다.

proxy cache : 공용 캐시에는 여러 사용자가 접근, 불필요한 트래픽을 줄일 수 있다.

### cache의 동작

1. 요청 받기 - 캐시는 네트워크로부터 도착한 요청 메시지를 읽는다
2. 파싱 - 캐시는 메시지를 파싱하며 URL과 헤더들을 추출한다
3. 검색 - 캐시는 로컬 복사본이 있는지 검사하고, 사본이 없다면 사본을 받아온다 (그리고 로컬 캐시에 저장한다)
4. 검사 - 캐시는 캐시된 사본이 유효한지 검사하고, 유효하지 않다면 서버에 요청한다
5. 응답 생성 - 캐시는 새로운 헤더와 캐시된 본문으로 응답 메시지를 만든다
6. 발송 - 캐시는 네트워크를 통해 응답을 클라이언트에게 돌려준다
7. (로깅) - 선택적으로, 캐시는 로그파일에 트랜잭션에 대해 서술한 로그 하나를 남긴다

### 검사 단계에서 사용하는 헤더들

| 헤더 | 설명 |
| --- | --- |
| Cache-Control: max-age=${seconds} | 문서의 최대 유효 시간(초 단위)를 정의한다. |
| Expires: ${Date} | 절대 유효기간을 명시한다. |

### 조건부 메서드와의 재검사

HTTP는 캐시가 서버에게 조건부 GET이라는 요청을 보낼 수 있도록 해준다. 이 요청은 서버가 갖고 있는 문서가 캐시가 갖고 있는 것과 다른 경우에만 객체 본문을 보내달라고 하는 것이다.

| 헤더 | 설명 |
| --- | --- |
| If-Modified-Since: ${Date} | 만약 문서가 주어진 날짜 이후로 수정되었다면 요청 메서드를 처리한다. |
| If-None-Match: ${tags} | 마지막 변경된 날짜를 맞춰보는 대신, 서버는 문서에 대한 일련번호와 같이 동작하는 특별한 태그(ETag)를 제공할 수 있다. 캐시된 태그가 서버에 있는 문서의 태그와 다를 때만 요청을 처리한다. |

**참고**

[https://guiyomi.tistory.com/130](https://guiyomi.tistory.com/130)

[https://hudi.blog/http-cache/](https://hudi.blog/http-cache/)